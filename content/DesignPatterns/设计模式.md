# 软件设计原则

| 设计原则     | 解释                                                       |
| ------------ | ---------------------------------------------------------- |
| 开闭原则     | 对扩展开放，对修改关闭                                     |
| 依赖倒置原则 | 通过抽象使各个类或者模块不相互影响，实现松耦合。           |
| 单一职责原则 | 一个类、接口、方法只做一件事。                             |
| 接口隔离原则 | 尽量保证接口的纯洁性，客户端不应该依赖不需要的接口。       |
| 迪米特法则   | 又叫最少知道原则，一个类对其所依赖的类知道得越少越好。     |
| 里氏替换原则 | 子类可以扩展父类的功能但不能改变父类原有的功能。           |
| 合成复用原则 | 尽量使用对象组合、聚合，而不使用继承关系达到代码复用的目的 |

设计模式最重要的是解耦。

# 设计模式之间的关联关系和对比

**单例模式和工厂模式**

实际业务代码中，通常会把工厂类设计为单例。

**策略模式和工厂模式**

1. 工厂模式包含工厂方法模式和抽象工厂模式是创建型模式，策略模式属于行为型模 式。 
2. 工厂模式主要目的是封装好创建逻辑，策略模式接收工厂创建好的对象，从而实现不 同的行为。

**策略模式和委派模式**

1. 策略模式是委派模式内部的一种实现形式，策略模式关注的结果是否能相互替代。 
2. 委派模式更关注分发和调度的过程。

**模板方法模式和工厂方法模式**

厂方法是模板方法的一种特殊实现。

**模板方法模式和策略模式**

1. 模板方法和策略模式都有封装算法。 
2. 策略模式是使不同算法可以相互替换，且不影响客户端应用层的使用。 
3. 模板方法是针对定义一个算法的流程，将一些有细微差异的部分交给子类实现。 
4. 模板方法模式不能改变算法流程，策略模式可以改变算法流程且可替换。策略模式通 常用来代替 if...else...等条件分支语句。

**装饰者模式和代理模式** 

1. 装饰者模式关注点在于给对象动态添加方法，而代理更加注重控制对对象的访问。
2. 代理模式通常会在代理类中创建被代理对象的实例，而装饰者模式通常把被装饰者作 为构造参数。

**装饰者模式和适配器模式**

1. 装饰者模式和适配器模式都是属于包装器模式(Wrapper Pattern)。 

2. 装饰者模式可以实现被装饰者与相同的接口或者继承被装饰者作为它的子类，而适配 器和被适配者可以实现不同的接口。

   