# UUID

- 生成足够简单，本地生成无网络消耗，具有唯一性
- 无序的字符串，不具备趋势自增特性，没有业务含义
- 长度过长，作为数据库主键 `UUID` 的无序性会导致数据位置频繁变动，严重影响性能。

# 数据库自增ID

当我们需要一个ID的时候，向表中插入一条记录返回主键ID

实现简单，ID单调自增，数值类型查询速度快。

DB单点存在宕机风险，无法扛住高并发场景。

# 基于数据库集群模式

双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。

设置`起始值`和`自增步长`

水平扩展的数据库集群，有利于解决数据库单点压力的问题，同时为了ID生成特性，将自增步长按照机器数量来设置。

增加第三台`MySQL`实例需要人工修改一、二两台`MySQL实例`的起始值和步长，把`第三台机器的ID`起始生成位置设定在比现有`最大自增ID`的位置远一些，但必须在一、二两台`MySQL实例`ID还没有增长到`第三台MySQL实例`的`起始ID`值的时候，否则`自增ID`就要出现重复了。

# 基于数据库的号段模式

号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：

```mysql
CREATE TABLE id_generator (
  id int(10) NOT NULL,
  max_id bigint(20) NOT NULL COMMENT '当前最大id',
  step int(20) NOT NULL COMMENT '号段的布长',
  biz_type    int(20) NOT NULL COMMENT '业务类型',
  version int(20) NOT NULL COMMENT '版本号',
  PRIMARY KEY (`id`)
) 
```

等这批号段ID用完，再次向数据库申请新号段，对`max_id`字段做一次`update`操作，`update max_id= max_id + step`，update成功则说明新号段获取成功，新的号段范围是`(max_id ,max_id +step]`。由于多业务端可能同时操作，所以采用版本号`version`乐观锁方式更新，这种`分布式ID`生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。

# Redis模式

`Redis`也同样可以实现，原理就是利用`redis`的 `incr`命令实现ID的原子性自增。

# 雪花算法

`Snowflake`生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。

Snowflake ID组成结构：`正数位`（占1比特）+ `时间戳`（占41比特）+ `机器ID`（占5比特）+ `数据中心`（占5比特）+ `自增值`（占12比特），总共64比特组成的一个Long类型。

根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。

强依赖时钟,如果主机时间回拨,则会造成重复ID

在单机上是递增的，但是在分布式环境下，每台机器的时钟不一定完全同步，所以不能满足严格递增，只能满足趋势递增。

毫秒数在高位，自增序列在低位，整个 ID 都是趋势递增的。

不依赖数据库第三方系统（区别于 Redis 集群生成的分布式 ID），以服务的方式部署，稳定性更高，生成 ID 的性能也常高。

可以根据自身业务特性分配 bit 位，非常灵活。