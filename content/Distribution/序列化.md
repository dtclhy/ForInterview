# 意义

序列化是把对象的状态信息转化为可存储或传输的形式过程，也就是把对象转化为字节序列
的过程称为对象的序列化

反序列化是序列化的逆向过程，把字节数组反序列化为对象，把字节序列恢复为对象的过程
成为对象的反序列化

# java序列化

serialVersionUID 有两种显示的生成方式:

一是默认的 1L，比如:private static final long serialVersionUID = 1L

二是根据类名、接口名、成员方法及属性等来生成一个 64 位的哈希字段。

当实现 java.io.Serializable 接口的类没有显式地定义一个 serialVersionUID 变量时候，Java 序列化机制会根据编译的 Class 自动生成一个 serialVersionUID 作序列化版本比较用，这种情况 下，如果 Class 文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算 再编译多次，serialVersionUID 也不会变化的。

Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变 量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。

# 分布式下序列化

**XML** **序列化框架介绍**

XML 序列化的好处在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大， 而且效率不高。同时 XML 又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。

**JSON** **序列化框架**

JSON是一种轻量级的数据交换格式，相对于 XML 来说，JSON 的字节流更小，而且可读性也非常好。

**Hessian** **序列化框架**

Hessian 是一个支持跨语言传输的二进制序列化协议，相对于 Java 默认的序列化机制来说， Hessian 具有更好的性能和易用性，而且支持多种不同的语言。

实际上 Dubbo 采用的就是 Hessian 序列化来实现，只不过 Dubbo 对 Hessian 进行了重构， 性能更高

**Protobuf** **序列化框架**

Protobuf 是一个纯粹的表示层协议，可以和各种传输层协议一起使用。主要是空间开销小和性能比较好。解析性能比较高，序列化以后数据量相对较少。

 Protobuf 有自己的语法和编译器。要传输的每一个类的结构都要生成对应的 proto 文件，如果某个类发生修改，还得重新生成该类对应的 proto 文件。

# Protobuf序列化的原理

使用 protobuf 开发的一般步骤是

1. 配置开发环境，安装 protocol compiler 代码编译器
2. 编写.proto 文件，定义序列化对象的数据结构
3. 基于编写的.proto 文件，使用 protocol compiler 编译器生成对应的序列化/反序列化工具类
4. 基于自动生成的代码，编写自己的序列化应用

序列化速度快的原因: 编码/解码方式简单(只需要简单的数学运算 = 位移等等)，采用 Protocol Buffer 自身的框架代码和编译器共同完成

序列化后的数据量体积小(即数据压缩效果好)的原因：采用了独特的编码方式，如 Varint、Zigzag 编码方式等等，采用 T - L - V 的数据存储方式，减少了分隔符的使用 & 数据存储得紧凑