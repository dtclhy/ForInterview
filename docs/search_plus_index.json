{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"content/JavaBasic/基本类型和包装类型.html":{"url":"content/JavaBasic/基本类型和包装类型.html","title":"基本类型和包装类型","keywords":"","body":"基本类型和包装类型的区别 包装类型可以为NULL，基本类型不可以 包装类型可以应用于 POJO 中，而基本类型则不行。数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱(将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 NullPointerException 的异常。 包装类型可用于泛型，基本类型不可以 泛型不能使用基本类型，因为使用基本类型时会编译出错。因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个特例。 基本类型比包装类型更高效 基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。 两个包装类型的值可以相同但却不相等 Integer chenmo = new Integer(10); Integer wanger = new Integer(10); System.out.println(chenmo == wanger); // false System.out.println(chenmo.equals(wanger )); // true 自动装箱和自动拆箱 把基本类型转换成包装类型的过程叫做装箱(boxing)。反之，把包装类型转换成基本类型的过程叫做拆箱(unboxing)。 自动装箱是通过 Integer.valueOf() 完成的，自动拆箱是通过 Integer.intValue() 完成的。 // 1）基本类型和包装类型 int a = 100; Integer b = 100; System.out.println(a == b);//true // 2）两个包装类型 Integer c = 100; Integer d = 100; System.out.println(c == d);//true // 3） c = 200; d = 200; System.out.println(c == d);//false 第一段代码，基本类型和包装类型进行 == 比较，这时候 b 会自动拆箱，直接和 a 比较值，所以结果为 true。 第二段代码，当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象(IntegerCache)而不是重新建一个对 象。100 在这个范围之内，结果是true。 第三段代码，200 不在这个范围之内，所以 new 出来了两个 Integer 对象，结果是 false。 "},"content/JavaBasic/多态.html":{"url":"content/JavaBasic/多态.html","title":"多态","keywords":"","body":"多态的定义 Java具备面向对象的三个特征：继承，封装和多态 多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术。在程序中定义的引用变量所指向的具体类型和通过该引用变量的方法调用在编程的时候并不确定，当处于运行期间才确定。这样不用修改源码就可以把变量绑定到不同的类实例上，让程序拥有了多个运行状态，这就是多态。 多态的三个前提条件： 1. 要有继承关系 2. 子类要重写父类的方法 3. 父类引用指向子类对象 补充一下第二点，既然多态存在必须要有“子类重写父类方法”这一条件，那么以下三种类型的方法是没有办法表现出多态特性的（因为不能被重写）： 1、static方法，因为被static修饰的方法是属于类的，而不是属于实例的 2、final方法，因为被final修饰的方法无法被子类重写 3、private方法和protected方法，前者是因为被private修饰的方法对子类不可见，后者是因为尽管被protected修饰的方法可以被子类见到，也可以被子类重写，但是它是无法被外部所引用的，一个不能被外部引用的方法，怎么能谈多态呢 多态的分类: 编译时多态，即方法的重载，从JVM的角度来讲，这是一种静态分派（static dispatch） 运行时多态，即方法的重写，从JVM的角度来讲，这是一种动态分派（dynamic dispatch 静态分派 静态分派原理 class Human{ } class Man extends Human{ } class Woman extends Human{ } public class StaticPai{ public void say(Human hum){ System.out.println(\"I am human\"); } public void say(Man hum){ System.out.println(\"I am man\"); } public void say(Woman hum){ System.out.println(\"I am woman\"); } public static void main(String[] args){ Human man = new Man(); Human woman = new Woman(); StaticPai sp = new StaticPai(); sp.say(man); sp.say(woman); } } // 执行结果为 I am human ，I am human 我们把上面代码中的“Human”称为变量的静态类型，后面的“Men”称为变量的实际类型。静态类型是在编译期间可知的；而实际类型变化的结果在运行期间才可确定，编译器在编译程序时并不知道一个对象的实际类型是什么。 mian()中两次调用sayHello()方法，在方法接受者已经确定是对象“sp”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。编译器在重载时通过参数的静态类型而不是实际类型作为判断依据的，因此在编译阶段Java编译器根据参数的静态类型决定使用哪个重载版本。 静态分派优先级 public class Overload { private static void sayHello(char arg){ System.out.println(\"hello char\"); } private static void sayHello(Object arg){ System.out.println(\"hello Object\"); } private static void sayHello(int arg){ System.out.println(\"hello int\"); } private static void sayHello(char... arg){ System.out.println(\"hello cHAR...\"); } // 测试代码 public static void main(String[] args) { sayHello('a'); } } // 运行结果 hello char 优先级顺序为：char>int>long>float>double>Character>Serializable>Object>... 其中...为变长参数，将其视为一个数组元素。变长参数的重载优先级最低。 因为 char 转型到 byte 或 short 的过程是不安全的，所以不会选择参数类型为byte 或 short的方法进行重载，故优先级列表里也没有。 上面讲解的主要是 基本数据类型的优先级匹配问题 若是引用类型，则根据 继承关系 进行优先级匹配 动态分派 // 定义类 class Human { public void sayHello(){ System.out.println(\"Human say hello\"); } } // 继承自 抽象类Human 并 重写sayHello() class Man extends Human { @Override protected void sayHello() { System.out.println(\"man say hello\"); } } class Woman extends Human { @Override protected void sayHello() { System.out.println(\"woman say hello\"); } } // 测试代码 public static void main(String[] args) { // 情况1 Human man = new man(); man.sayHello(); // 情况2 man = new Woman(); man.sayHello(); } } // 运行结果 man say hello woman say hello invokevirtual指令多态查找执行的第一步就是在运行期确定接收者（执行sayhello方法的对象）的实际类型，第二步将常量池中类方法符号引用解析到不同的直接引用上。这个过程就是Java语言中方法重写的本质。 两者的区别 类型 分派原理 发生阶段 应用场景 静态分派 根据变量的静态类型 编译器（不由虚拟机执行） 方法重载 动态分派 根据变量的动态类型 运行期（由虚拟机执行） 方法重写 "},"content/JavaBasic/泛型.html":{"url":"content/JavaBasic/泛型.html","title":"泛型","keywords":"","body":"泛型的定义 泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。其存在的意义在于： 强制的类型检查：Java 编译器会对泛型代码进行强制类型检查，如果违反类型安全则会抛出错误。在编译阶段解决类型错误，能更有效的减少 Bug 消除类型强制转换：如果不使用泛型，则在进行代码编写是需要手动进行类型转换 实现通用算法：通过泛型，程序员能在不同类型的集合上实现通用算法 泛型类、方法、接口 /** * Description: 泛型方法 */ public class GenericMethod3 { static class Animal { @Override public String toString() { return \"Animal\"; } } static class Dog extends Animal { @Override public String toString() { return \"Dog\"; } } static class Fruit { @Override public String toString() { return \"Fruit\"; } } //泛型类 static class GenericClass { public void show01(T t) { System.out.println(t.toString()); } //泛型方法 public void show02(T t) { System.out.println(t.toString()); } public void show03(K k) { System.out.println(k.toString()); } } public static void main(String[] args) { Animal animal = new Animal(); Dog dog = new Dog(); Fruit fruit = new Fruit(); GenericClass genericClass = new GenericClass<>(); //泛型类在初始化时限制了参数类型 genericClass.show01(dog); // genericClass.show01(fruit); //泛型方法的参数类型在使用时指定 genericClass.show02(dog); genericClass.show02(fruit); genericClass.show03(animal); genericClass.show03(dog); genericClass.show03(fruit); // genericClass.show03(animal); } } 通配符 指定了泛型类型的上界 指定了泛型类型的下界 指定了没有限制的泛型类型 类型擦除（泛型的实现） Java 语言引入了泛型，以在编译时提供更严格的类型检查并支持泛型编程。为实现泛型 Java 编译器会进行类型擦除： 替换所有类型参数为他们的上界或者 Object，因此，字节码仅包含普通的类，接口和方法。 必要时插入类型转换，以保持类型安全。 生成桥接方法以在扩展的泛型类型中保留多态。 类型擦除可确保不会为参数化类型创建新的类；因此，泛型不会产生运行时开销。 泛型类型的擦除 在类型擦除过程中，Java 编译器将擦除所有类型参数，如果类型参数是有界的，则将每个参数替换为其第一个边界；如果类型参数是无界的，则将其替换为 Object。 public class Node { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } 由于 T 是无界的，所以其类型擦除后的代码为： public class Node { private Object data; private Node next; public Node(Object data, Node next) { this.data = data; this.next = next; } public Object getData() { return data; } // ... } 而对于以下代码的擦除又不一样： public class Node> { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } //擦除后 public class Node { private Comparable data; private Node next; public Node(Comparable data, Node next) { this.data = data; this.next = next; } public Comparable getData() { return data; } // ... } 泛型方法擦除 泛型方法的擦除规则和泛型类型的擦除规则类似： // Counts the number of occurrences of elem in anArray. public static int count(T[] anArray, T elem) { int cnt = 0; for (T e : anArray) if (e.equals(elem)) ++cnt; return cnt; } public static void draw(T shape) { /* ... */ } //擦除后 public static int count(Object[] anArray, Object elem) { int cnt = 0; for (Object e : anArray) if (e.equals(elem)) ++cnt; return cnt; } public static void draw(Shape shape) { /* ... */ } 桥接方法 对于以下两个类： public class Node { public T data; public Node(T data) { this.data = data; } public void setData(T data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } 类型擦除： public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } 在类型擦除后，方法的签名不匹配，导致重写的方法不生效，Node.setData(T) 变成了 Node.setData(Object)。为解决这个问题，Java 编译器在子类型中生成桥接方法，对于 MyNode 其生成的方法如下： class MyNode extends Node { // Bridge method generated by the compiler // public void setData(Object data) { setData((Integer) data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } // ... } 这样，在类型擦除之后，MyNode 具有与 Node 的 setData(Object) 方法相同的方法签名的桥接方法，并将其委托给的 setData(Integer) 方法。 "},"content/JavaConcurrency/JMM.html":{"url":"content/JavaConcurrency/JMM.html","title":"内存模型JMM","keywords":"","body":"JMM的定义 Java内存模型(Java Memory Model简称JMM)是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。 JMM 抽象模型分为主内存、工作内存。主内存是共享内存区域，所有变量都存储在主内存。工作内存是每个线程独占的，线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存。线程间的通信(传值)必须通过主内存来完成。 此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的。主内存从某个程度上讲应该包括了堆和方法区，而工作内存从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。 JMM内存交互操作 lock(锁定)作用于主内存的变量，把一个变量标记为一条线程独占状态 unlock(解锁):作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read(读取):作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load(载入):作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use(使用):作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎。 assign(赋值):作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量。 store(存储):作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中， 以便随后的write的操作。 write(写入):作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中。 JMM内存同步规则 如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作， 如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。 不允许一个线程无原因地(没有发生过任何assign操作)把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load 或者assign)的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load 操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复 执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和 unlock必须成对出现。 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变 量之前需要重新执行load或assign操作初始化变量的值。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中(执行store和write操 作) "},"content/JavaConcurrency/volatile.html":{"url":"content/JavaConcurrency/volatile.html","title":"Volatile","keywords":"","body":"volatile的特性 volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下作用 可见性。保证被volatile修饰的共享变量对所有线程总数可见 有序性。禁止指令重排序优化 不能保证原子性。对单个volatile变量的读写具有原子性。对i++这种复合操作不具有原子性 volatile的可见性 JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步回主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。 底层实现：通过汇编的lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存内存会导致其他处理器的缓存无效。 缓存一致性 解决缓存不一致的问题，在 CPU 层面做了很多事情， 主要提供了两种解决办法：总线锁和缓存锁 总线锁。在多CPU下，当其中一个处理器要对共享内存进行操作的时候，在总线上发出一个 LOCK# 信号，这个信号使得其他处理器无法通过总线来访问到共 享内存中的数据，总线锁定把 CPU 和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据。所以总线锁定的开销比较大。 缓存锁。就是控制锁的保护粒度，保证对于被多个 CPU 缓存的同一份数据是一致的就行，它核心机制是基于缓存一致性协议来实现的。 缓存一致性协议 最常见的就是 MESI 协议。 只有Core 0访问变量x，它的Cache line状态为E(Exclusive)。 3个Core都访问变量x，它们对应的Cache line为S(Shared)状态。 Core 0修改了x的值之后，这个Cache line变成了M(Modified)状态，其他Core对应的Cache line变成了I(Invalid)状态。 在MESI协议中，每个Cache的Cache控制器不仅知道自己的读写操作，而且也监听(snoop)其它Cache的读写操作。每个Cache line所处的状态根据本核和其它核的读写操作在4个状态间进行迁移。 volatile的有序性 java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。重排序分为编译器重排序和处理器重排序。 为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。 禁止编译器重排序 下图是JMM针对编译器制定的volatile重排序规则表。 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile写之前的操作不会被编译器重排序到volatile写之后。当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile读之后的操作不会被编译器重排序到volatile读之前。当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。 禁止处理器重排序 编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。 下面是基于保守策略的JMM内存屏障插入策略。 在每个volatile写操作的前面插入一个StoreStore屏障。在每个volatile写操作的后面插入一个StoreLoad屏障。在每个volatile读操作的后面插入一个LoadLoad屏障。在每个volatile读操作的后面插入一个LoadStore屏障。 屏障类型 指令示例 说明 LoadLoadBarriers Load1;LoadLoad;Load2 该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作 StoreStoreBarriers Store1;StoreStore;Store2 该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作 LoadStoreBarriers Load1;LoadStore;Store2 确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作 StoreLoadBarriers Store1;StoreLoad;Load1 该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作.它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令 下面通过具体的示例代码进行说明 class VolatileBarrierExample { int a; volatile int v1 = 1; volatile int v2 = 2; void readAndWrite() { int i = v1; // 第一个volatile读 int j = v2; // 第二个volatile读 a = i + j; // 普通写 v1 = i + 1; // 第一个volatile写 v2 = j * 2; // 第二个 volatile } } volatile不能保证原子性 public class VolatileVisibility { public static volatile int i = 0; public static void increase(){ i++; } } 在并发场景下，i变量的任何改变都会立马反应到其他线程中，但是如此存在多条线程同时 调用increase()方法的话，就会出现线程安全问题，毕竟i++操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一 个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败。 总线风暴 由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值。 "},"content/JavaConcurrency/synchronized.html":{"url":"content/JavaConcurrency/synchronized.html","title":"Synchronized","keywords":"","body":"synchronized 的基本认识 synchronized 有三种方式来加锁，分别是 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 不同的修饰类型，代表锁的控制粒度。 synchronized存储 HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头 (Header)、实例数据(Instance Data)和对齐填充(Padding)。 对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁(线程)ID，偏向时间，数组长度(数组对象)等 实例数据：即创建对象时，对象中成员变量，方法等。 对齐填充：对象的大小必须是8字节的整数倍。 instanceOopDesc继承自 oopDesc，oopDesc 的定义载 Hotspot 源码中的 oop.hpp 文件中。oopDesc 的定义包含两个成员mark 和 _metadata。_mark 表示对象标记、属于 markOop 类型，也就是Mark World。metadata 表示类元信息，类元信息存储的是对象指向它的类元数据的首地址。 Mark World Mark word 记录了对象和锁有关的信息，当某个对象被 synchronized 关键字当成同步锁时，那么围绕这个锁的一系列操作都和 Mark word 有关系。 为什么任何对象都可以实现锁 首先，Java 中的每个对象都派生自 Object 类，而每个Java Object 在 JVM 内部都有一个 native 的 C++对象oop/oopDesc 进行对应。 线程在获取锁的时候，实际上就是获得一个监视器对象(monitor)，monitor 可以认为是一个同步对象，所有的 Java 对象是天生携带 monitor。 锁的升级 锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的 竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单 向的，也就是说只能从低到高升级，不会出现锁的降级。 偏向锁 偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，会在对象头中存储当前线程的ID。当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程。 当存在 2 个以上的线程竞争，如果开启偏向锁，反而会提升获取锁的资源消耗。所以可以通过 jvm 参数UseBiasedLocking 来设置开启或关闭偏向锁。 轻量级锁 倘若偏向锁失败，虚拟机会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。 自旋锁 轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，会进行自旋锁的优化手段。如果直接挂起，线程之间的切换需要从用户态转换到核心态。默认情况下自旋的次数是 10 次， 可以通过 preBlockSpin 来修改。在 JDK1.6 之后，引入了自适应自旋锁，自适应意味着自旋的次数不是固定不变的，而是根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。 重量级锁 当轻量级锁膨胀到重量级锁之后，意味着线程只能被挂起阻塞来等待被唤醒了。在字节码中会看到一个 monitorenter 和 monitorexit。monitorenter 表示去获得一个对象监视器。monitorexit 表示释放 monitor 监视器的所有权，使得其他被阻塞的线程可以尝试去获得这个监视器 monitor 依赖操作系统的 MutexLock(互斥锁)来实现的, 线程被阻塞后便进入内核(Linux)调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。 任意线程对 Object(Object 由 synchronized 保护)的访问，首先要获得 Object 的监视器。如果获取失败，线程进入同步队列，线程状态变为 BLOCKED。当访问 Object 的前驱(获得了锁的线程)释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。 "},"content/JavaConcurrency/ReentrantLock.html":{"url":"content/JavaConcurrency/ReentrantLock.html","title":"Lock","keywords":"","body":"Lock 几个常见的锁实现 ReentrantLock:表示重入锁，它是唯一一个实现了 Lock 接口的类。重入锁指的是线程在获得锁之后，再次获取该锁不需要阻塞，而是直接关联一次计数器增加重入次数 ReentrantReadWriteLock:重入读写锁，它实现了 ReadWriteLock 接口，在这个类中维护了两个锁，ReadLock和WriteLock，他们都分别实现了 Lock 接口。读写锁是一种适合读多写少的场景下解决线程安全问题的工具，基本原则是: 读和读不互斥、读和写互斥、写和写互斥。 StampedLock: stampedLock 是 JDK8 引入的新的锁机制，可以简单认为是读写锁的一个改进版本，读写锁虽然通过分离读和写的功能使得读和读之间可以完全并发，但是读和写是有冲突的，如果大量的读线程存在，可能会引起写线程的饥饿。stampedLock 是一种乐观的读策略，使得乐观锁完全不会阻塞写线程 使用案例 //Reenrantlock Lock lock=new ReentrantLock(); lock.lock(); lock.unlock(); //ReentrantReadWriteLock ReentrantReadWriteLock rwl=new ReentrantReadWriteLock(); Lock read=rwl.readLock(); Lock write=rwl.writeLock(); ReentrantLock的实现原理 AQS AQS，全称 AbstractQueuedSynchronizer，它是一个同步工具也是 Lock 用来实现线程同步的核心组件。 AQS内部维护属性volatile int state表示资源的可用状态 AQS定义两种资源共享方式。Exclusive-独占，Share-共享 AQS定义两种队列。同步等待队列，条件等待队列 同步等待队列 同步等待队列是一个 FIFO 的双向链表。当线程争抢锁失败后会封装成 Node 加入到队列中，当获取锁的线程释放锁以 后，会从队列中唤醒一个阻塞的节点(线程)。 条件等待队列 条件等待队列使某个或者某些线程一起等待某个条件(Condition)，只有当该条件具备时，这些等待线程才会被唤醒，从而重新争夺锁。 源码分析 锁的获取流程 时序图 ReentrantLock.lock()调用时序图 ReentrantLock.lock() 这个是reentrantLock获取锁的入口，Sync有两个具体的实现NofairSync和FailSync。 public void lock() { sync.lock(); } NofairSync.lock() CAS 成功，就表示成功获得了锁。CAS 失败，调用 acquire(1)走锁竞争 final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } AQS.accquire() public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 通过 tryAcquire 尝试获取独占锁，如果成功返回 true，失败返回 false。 如果 tryAcquire 失败，则会通过 addWaiter 方法将当前线程封装成 Node 添加到 AQS 队列尾部。 acquireQueued，将 Node 作为参数，通过自旋去尝试获取锁。 NonfairSync.tryAcquire protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } ReentrantLock.nofairTryAcquire 获取当前线程，判断当前的锁的状态。如果 state=0 表示当前是无锁状态，通过 cas 更新 state 状态的值 。当前线程是属于重入，则增加重入次数 final boolean nonfairTryAcquire(int acquires) { //获取当前执行的线程 final Thread current = Thread.currentThread(); int c = getState();//获得 state 的值 if (c == 0) {//表示无锁状态 //cas替换state的值，cas 成功表示获取锁成功 if (compareAndSetState(0, acquires)) { //保存当前获得锁的线程,下次再来的时候不要再尝试竞争锁 setExclusiveOwnerThread(current); return true; } }else if (current == getExclusiveOwnerThread()) { //如果同一个线程来获得锁，直接增加重入次数 int nextc = c + acquires; if (nextc AQS.addWaiter 当 tryAcquire 方法获取锁失败以后，则会先调用addWaiter将当前线程封装成Node。传递Node.EXCLUSIVE，表示独占状态。当前链表中的 tail 节点是否为空，如果不为空，则通过 cas 操作把当前线程的node 添加到 AQS 队列。如果为空或者 cas 失败，调用 enq 将节点添加到 AQS 队列 private Node addWaiter(Node mode) { //把当前线程封装为 Node Node node = new Node(Thread.currentThread(), mode); //tail 是 AQS 中表示同步队列队尾的属性，默认是 null Node pred = tail; if (pred != null) {//tail 不为空的情况下，说明队列中存在节点 node.prev = pred;//把当前线程的 Node 的 prev 指向 tail //通过 cas 把 node加入到 AQS 队列，也就是设置为 tail指向当前 node if (compareAndSetTail(pred, node)) { //设置成功以后，把原 tail 节点的next指向当前 node pred.next = node; return node; } } enq(node);//tail=null,把 node 添加到同步队列 return node; } //enq 就是通过自旋操作把当前节点加入到队列中 private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 图解分析 假设 3 个线程来争抢锁，那么截止到 enq 方法运行结束之后，或者调用 addwaiter 方法结束后，AQS 中的链表结构图 AQS.acquireQueued 通过 addWaiter 方法把线程添加到链表后，会接着把 Node 作为参数传递给 acquireQueued 方法，去竞争锁 获取当前节点的 prev 节点.如果 prev 节点为 head 节点，那么它就有资格去争抢锁，调用 tryAcquire 抢占锁. 如果获得锁失败，则根据 waitStatus 决定是否需要挂起线程 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor();//获取当前节点的 prev 节点 if (p == head && tryAcquire(arg)) { //如果是 head 节点，说明有资格去争抢锁 setHead(node); //获得锁的节点设置为 head p.next = null; //把原 head 节点从链表中移除 failed = false; return interrupted; } //ThreadA 可能还没释放锁，使得 ThreadB 在执行tryAcquire时会返回false if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; //返回当前线程在等待过程中有没有中断过。 } } finally { if (failed) cancelAcquire(node); } } shouldParkAfterFailedAcquire 这个方法的主要作用是，通过Node的状态来判断，竞争锁失败以后是否应该被挂起。如果pred 节点状态为 SIGNAL，那就表示可以放心挂起当前线程。通过循环扫描链表把 CANCELLED 状态的节点移除。修改 pred 节点的状态为 SIGNAL，返回 false。 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { int ws = pred.waitStatus;//前置节点的waitStatus if (ws == Node.SIGNAL) return true;//返回 true，意味着可以直接放心的挂起了 if (ws > 0) {//ws大于0，意味着prev节点取消了排队，直接移除这个节点 do { node.prev = pred = pred.prev; //相当于: pred=pred.prev; node.prev=pred; } while (pred.waitStatus > 0); //从列表中移除 CANCELLED 的节点 pred.next = node; } else {//利用 cas 设置 prev 节点的状态为 SIGNAL(-1) compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } parkAndCheckInterrupt LockSupport.park 挂起当前线程 Thread.interrupted，返回当前线程是否被其他线程触发过中断请求。如果返回 true，意味着在 acquire 方法中会执行selfInterrupt() private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } 图解分析 锁的释放流程 ReentrantLock.unlock 在 unlock 中，会调用 release 方法来释放锁 public final boolean release(int arg) { if (tryRelease(arg)) { //释放锁成功 Node h = head; //得到 aqs 中 head 节点 //如果 head 节点不为空并且状态!=0.调用唤醒后续节点 if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } ReentrantLock.tryRelease 这个方法可以认为是一个设置锁状态的操作，通过将 state 状态减掉传入的参数值 (参数是 1)，如果结果状态为 0，就将排它锁的 Owner 设置为 null，以使得其它的线程有机会进行执行。 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } unparkSuccessor private void unparkSuccessor(Node node) { int ws = node.waitStatus;//获得 head 节点的状态 if (ws 0 表示 cancelled 状态. 通过 //从尾部节点开始扫描，找到距离 head 最近的一个 if (s == null || s.waitStatus > 0) { waitStatus 挂起的线程继续执行 通过 ReentrantLock.unlock，原本挂起的线程被唤醒以后继续执行。原来被挂起的线程是在 acquireQueued 方法中，所以被唤醒以后继续从这个方法开始执行。 设置新的头节点，新 head 节点的 prev=null。把原 head 节点的 next 节点指向为 null。 图解分析 通过锁的释放，原本的结构就发生了一些变化。head 节点的 waitStatus 变成了 0，ThreadB 被唤醒。 设置新 head 节点的 prev=null，设置原 head 节点的 next 节点为 null。 公平锁和非公平锁 FairSync.tryAcquire protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc 这个方法与 nonfairTryAcquire(int acquires)比较，不同的地方在于判断条件多了hasQueuedPredecessors()方法，也就是加入了同步队列中当前节点是否有前驱节点]的判断，如果该方法返回 true，则表示有线程比当前线程更早地请求获取锁， 因此需要等待前驱线程获取并释放锁之后才能继续获取锁。 "},"content/JavaConcurrency/Condition.html":{"url":"content/JavaConcurrency/Condition.html","title":"并发工具","keywords":"","body":"Condition Condition 基本使用 ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); condition.await(); condition.signal(); Condition 源码分析 调用 Condition，需要获得 Lock 锁，意味着会存在一个 AQS 同步队列。假如两个线程同时运行的话，那么 AQS 的队列可能是下面这种情况。 condition.await 调用 Condition 的 await()方法(或者以 await 开头的方法)，会使当前线程进入等待队列并释 放锁，同时线程状态变为等待状态。当从 await()方法返回时，当前线程一定获取了 Condition 相关联的锁。 public final void await() throws InterruptedException { if (Thread.interrupted()) //表示await允许被中断 throw new InterruptedException(); //创建一个新的节点，节点状态为 condition，采用的数据结构为单向链表 Node node = addConditionWaiter(); //释放当前的锁，得到锁的状态，并唤醒AQS队列中的一个线程 int savedState = fullyRelease(node); int interruptMode = 0; //如果当前节点没有在同步队列上，即还没有被 signal，则将当前线程阻塞 while (!isOnSyncQueue(node)) { //判断这个节点是否在 AQS 队列上，第一次判断的是 false，因为前面释放 //锁了 LockSupport.park(this); //通过 park 挂起当前线程 if((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } // 当这个线程醒来,会尝试拿锁,acquireQueued返回false 就是拿到锁了 if (acquireQueued(node, savedState) && interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); // 如果线程被中断了,需要抛出异常.或者什么都不做 if (interruptMode != 0) reportInterruptAfterWait(interruptMode); addConditionWaiter 这个方法的主要作用是把当前线程封装成 Node，添加到等待队列。这里的队列不再是双向链表，而是单向链表。 private Node addConditionWaiter() { Node t = lastWaiter; if (t != null && t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } //构建一个Node，waitStatus=CONDITION。 这里的链表是一个单向的 Node node = new Node(Thread.currentThread(), Node.CONDITION) if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; } 执行完 addConditionWaiter 这个方法之后，就会产生一个这样的 condition 队列。 fullyRelease fullRelease，就是如果当前锁存在多次重入，那么在这个方法中只需要释放一次就会把所有的重入次数归零。 final int fullyRelease(Node node) { boolean failed = true; try { int savedState = getState(); //获得重入的次数 if (release(savedState)) {//释放锁并且唤醒下一个同步队列中的线程 failed = false; return savedState; } else { throw new IllegalMonitorStateException(); } } finally { if (failed) node.waitStatus = Node.CANCELLED; } } 此时，同步队列会触发锁的释放和重新竞争。ThreadB 获得了锁。 isOnSyncQueue 判断当前节点是否在同步队列中，返回 false 表示不在，返回 true 表示在。如果不在 AQS 同步队列，说明当前节点没有唤醒去争抢同步锁，所以需要把当前线程阻塞起来，直到其他的线程调用 signal 唤醒。 如果 ThreadA 的 waitStatus 的状态为 CONDITION，说明它存在于 condition 队列中，不在 AQS 队列。因为 AQS 队列的状态一定不可能有 CONDITION 如果 node.prev 为空，说明也不存在于 AQS 队列，原因是 prev=null 在 AQS 队列中只有一种可能性，就是它是 head 节点，head 节点意味着它是获得锁的节点。 如果 node.next 不等于空，说明一定存在于 AQS 队列中，因为只有 AQS 队列才会存在next 和 prev 的关系 findNodeFromTail，表示从 tail 节点往前扫描 AQS 队列，一旦发现 AQS 队列的节点和当前节点相等，说明节点一定存在于 AQS 队列中 final boolean isOnSyncQueue(Node node) { if (node.waitStatus == Node.CONDITION || node.prev== null) return false; if (node.next != null) // If has successor,it mustbe on queue return true; return findNodeFromTail(node); } Condition.signal await 方法会阻塞 ThreadA，然后 ThreadB 抢占到了锁获得了执行权限，这个时候在 ThreadB 中调用了 Condition 的 signal()方法，将会唤醒在等待队列中节点。 public final void signal() { //先判断当前线程是否获得了锁，这个判断比较简单，直接用获得锁的线程和当前线程相比即可 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; // 拿到 Condition 队列上第一个节点 if (first != null) doSignal(first); } private void doSignal(Node first) { do { //从 Condition 队列中删除 first 节点 if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; // 将 next 节点设置成 null first.nextWaiter = null; } while(!transferForSignal(first&&(first =firstWaiter) !=null); } transferForSignal 该方法先是 CAS 修改了节点状态，如果成功，将这个节点放到 AQS 队列中，然后唤醒 这个节点上的线程。此时，那个节点就会在 await 方法中苏醒。 final boolean transferForSignal(Node node) { //更新节点的状态为0如果更新失败，只有一种可能就是节点被 CANCELLED 了 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //调用enq，把当前节点添加到AQS队列。并且返回返回按当前节点 Node p = enq(node); int ws = p.waitStatus; // 如果上一个节点的状态被取消了, 或设置上一个节点的状态为SIGNAL失败了 if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); // 唤醒节点上的线程. //如果node的prev节点已经是signal状态，那么被阻塞线程唤醒工作由 AQS 队 //列来完成 return true; CountDownLatch CountDownLatch基本使用 CountDownLatch countDownLatch = new CountDownLatch(3); //countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0 countDownLatch.countDown(); //await 是一个阻 塞方法，当 state 减为 0 的时候，await 方法才会返回 countDownLatch.await(); CountDownLatch源码分析 countDownLatch.await() public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) doAcquireSharedInterruptibly private void doAcquireSharedInterruptibly(int arg)throws InterruptedException { final Node node = addWaiter(Node.SHARED); //创建一个共享模式的节点添加到队列中 boolean failed = true; try { for (;;) { final Node p = node.predecessor(); if (p == head) { int r = tryAcquireShared(arg);//就判断尝试获取锁 if (r >= 0) {//r>=0表示获取到了执行权限，这个时候因为state!=0，所以不会执行这段代码 setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; } } //阻塞线程 if (shouldParkAfterFailedAcquire(p, node) &&parkAndCheckInterrupt()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } 假如这个时候有 3 个线程调用了 await 方法，由于这个时候 state 的值还不为 0，所以这三个线程都会加入到 AQS 队列中。并且三个线程都处于阻塞状态。 CountDownLatch.countDown public void countDown() { sync.releaseShared(1); } public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } //用自旋的方式减1 protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } } AQS. doReleaseShared 共享锁的释放和独占锁的释放有一定的差别。前面唤醒锁的逻辑和独占锁是一样，先判断头结点是不是 SIGNAL 状态，如果是，则修改为 0，并且唤醒头结点的下一个节点。 标识为 PROPAGATE状态的节点，是共享锁模式下的节点状态，处于这个状态下的节点，会对线程的唤醒进行传播。 private void doReleaseShared() { for (;;) { Node h = head; if (h != null && h != tail) { int ws = h.waitStatus; if (ws == Node.SIGNAL){ if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } // 这个 CAS 失败的场景是:执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1 else if (ws == 0 && !compareAndSetWaitStatus(h,0,Node.PROPAGATE)) continue; // loop on failed CAS } // 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再 循环 // 通过检查头节点是否改变了，如果改变了就继续循环 if (h == head) // loop if head changed break; } } h == head说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程(这里可以理解为 ThreadB)占有，此时 break 退出循环。 h != head说明头节点被刚刚唤醒的线程(这里可以理解为 ThreadB)占有，那么这里重新进入下一轮循环，唤醒下一个节点。我们知道，等到 ThreadB 被唤醒后，其实是会主动唤醒 ThreadC。 唤醒之后 一旦线程被唤醒，代码又会继续回到 doAcquireSharedInterruptibly 中来执行。如果当前 state 满足=0 的条件，则会执行 setHeadAndPropagate 方法。 private void setHeadAndPropagate(Node node, int propagate) { Node h = head; // Record old head for check below setHead(node); if (propagate > 0 || h == null || h.waitStatus PROPAGATE状态存在的意义 在setHeadAndPropagate中我们可以看到如下的一段代码: if (propagate > 0 || h == null || h.waitStatus 为什么不只是用propagate > 0来判断呢？我们知道目前AQS代码中的Node.PROPAGATE状态就是为了此处可以读取到h.waitStatus 看一下下面的bug import java.util.concurrent.Semaphore; public class TestSemaphore { private static Semaphore sem = new Semaphore(0); private static class Thread1 extends Thread { @Override public void run() { sem.acquireUninterruptibly(); } } private static class Thread2 extends Thread { @Override public void run() { sem.release(); } } public static void main(String[] args) throws InterruptedException { for (int i = 0; i 让我们来分析一下上面的程序： 上面的程序循环中做的事情就是放出4个线程，其中2个线程用于获取信号量，另外2个用于释放信号量。每次循环主线程会等待所有子线程执行完毕。出现bug也就是线程hang住的问题就在于两个获取信号量的线程有一个会没办法被唤醒，队列就死掉了。 在AQS的共享锁中，一个被park的线程，不考虑线程中断和前驱节点取消的情况，有两种情况可以被unpark：一种是其他线程释放信号量，调用unparkSuccessor；另一种是其他线程获取共享锁时通过传播机制来唤醒后继节点。 我们假设某次循环中队列里排队的节点为情况为：head -> t1的node -> t2的node(也就是tail) 信号量释放的顺序为t3先释放，t4后释放: 时刻1: t3调用releaseShared，调用了unparkSuccessor(h)，head的等待状态从-1变为0 时刻2: t1由于t3释放了信号量，被t3唤醒，调用Semaphore.NonfairSync的tryAcquireShared，返回值为0 时刻3: t4调用releaseShared,读到此时h.waitStatus为0(此时读到的head和时刻1中为同一个head)，不满足条件,因此不会调用unparkSuccessor(h)。 时刻4: t1获取信号量成功，调用setHeadAndPropagate时，因为不满足propagate > 0（时刻2的返回值也就是propagate==0）,从而不会唤醒后继节点 这就好比是一个精巧的多米诺骨牌最终由于设计的失误导致动力无法传递下去，至此AQS中的同步队列宣告死亡。 那么引入PROPAGATE是怎么解决问题的呢？引入之后，调用releaseShared方法不再简单粗暴地直接unparkSuccessor,而是将传播行为抽了一个doReleaseShared方法出来。再看上面的那种情况: 时刻1：t3调用releaseShared -> doReleaseShared -> unparkSuccessor，完了之后head的等待状态为0 时刻2：t1由于t3释放了信号量，被t3唤醒，调用Semaphore.NonfairSync的tryAcquireShared，返回值为0 时刻3：t4调用releaseShared，读到此时h.waitStatus为0(此时读到的head和时刻1中为同一个head)，将等待状态置为PROPAGATE 时刻4：t1获取信号量成功，调用setHeadAndPropagate时，可以读到h.waitStatus ，从而可以接下来调用doReleaseShared唤醒t2 也就是说，上面会产生线程hang住bug的case在引入PROPAGATE后可以被规避掉。在PROPAGATE引入之前，之所以可能会出现线程hang住的情况，就是在于releaseShared有竞争的情况下，可能会有队列中处于等待状态的节点因为第一个线程完成释放唤醒，第二个线程获取到锁，但还没设置好head，又有新线程释放锁，但是读到老的head状态为0导致释放但不唤醒，最终后一个等待线程既没有被释放线程唤醒，也没有被持锁线程唤醒。所以，仅仅靠tryAcquireShared的返回值来决定是否要将唤醒传递下去是不充分的。 "},"content/MiddleWare/redis.html":{"url":"content/MiddleWare/redis.html","title":"test3","keywords":"","body":"test markdown 级六级考六级了剋 i 还不是个看不见各地广泛的高大上 Nkjhk weee jkhb kkk "}}