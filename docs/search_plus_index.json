{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"content/JavaBasic/基本类型和包装类型.html":{"url":"content/JavaBasic/基本类型和包装类型.html","title":"基本类型和包装类型","keywords":"","body":"基本类型和包装类型的区别 包装类型可以为NULL，基本类型不可以 包装类型可以应用于 POJO 中，而基本类型则不行。数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱(将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 NullPointerException 的异常。 包装类型可用于泛型，基本类型不可以 泛型不能使用基本类型，因为使用基本类型时会编译出错。因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个特例。 基本类型比包装类型更高效 基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。 两个包装类型的值可以相同但却不相等 Integer chenmo = new Integer(10); Integer wanger = new Integer(10); System.out.println(chenmo == wanger); // false System.out.println(chenmo.equals(wanger )); // true 自动装箱和自动拆箱 把基本类型转换成包装类型的过程叫做装箱(boxing)。反之，把包装类型转换成基本类型的过程叫做拆箱(unboxing)。 自动装箱是通过 Integer.valueOf() 完成的，自动拆箱是通过 Integer.intValue() 完成的。 // 1）基本类型和包装类型 int a = 100; Integer b = 100; System.out.println(a == b);//true // 2）两个包装类型 Integer c = 100; Integer d = 100; System.out.println(c == d);//true // 3） c = 200; d = 200; System.out.println(c == d);//false 第一段代码，基本类型和包装类型进行 == 比较，这时候 b 会自动拆箱，直接和 a 比较值，所以结果为 true。 第二段代码，当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象(IntegerCache)而不是重新建一个对 象。100 在这个范围之内，结果是true。 第三段代码，200 不在这个范围之内，所以 new 出来了两个 Integer 对象，结果是 false。 "},"content/JavaBasic/多态.html":{"url":"content/JavaBasic/多态.html","title":"多态","keywords":"","body":"多态的定义 Java具备面向对象的三个特征：继承，封装和多态 多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术。在程序中定义的引用变量所指向的具体类型和通过该引用变量的方法调用在编程的时候并不确定，当处于运行期间才确定。这样不用修改源码就可以把变量绑定到不同的类实例上，让程序拥有了多个运行状态，这就是多态。 多态的三个前提条件： 1. 要有继承关系 2. 子类要重写父类的方法 3. 父类引用指向子类对象 补充一下第二点，既然多态存在必须要有“子类重写父类方法”这一条件，那么以下三种类型的方法是没有办法表现出多态特性的（因为不能被重写）： 1、static方法，因为被static修饰的方法是属于类的，而不是属于实例的 2、final方法，因为被final修饰的方法无法被子类重写 3、private方法和protected方法，前者是因为被private修饰的方法对子类不可见，后者是因为尽管被protected修饰的方法可以被子类见到，也可以被子类重写，但是它是无法被外部所引用的，一个不能被外部引用的方法，怎么能谈多态呢 多态的分类: 编译时多态，即方法的重载，从JVM的角度来讲，这是一种静态分派（static dispatch） 运行时多态，即方法的重写，从JVM的角度来讲，这是一种动态分派（dynamic dispatch 静态分派 静态分派原理 class Human{ } class Man extends Human{ } class Woman extends Human{ } public class StaticPai{ public void say(Human hum){ System.out.println(\"I am human\"); } public void say(Man hum){ System.out.println(\"I am man\"); } public void say(Woman hum){ System.out.println(\"I am woman\"); } public static void main(String[] args){ Human man = new Man(); Human woman = new Woman(); StaticPai sp = new StaticPai(); sp.say(man); sp.say(woman); } } // 执行结果为 I am human ，I am human 我们把上面代码中的“Human”称为变量的静态类型，后面的“Men”称为变量的实际类型。静态类型是在编译期间可知的；而实际类型变化的结果在运行期间才可确定，编译器在编译程序时并不知道一个对象的实际类型是什么。 mian()中两次调用sayHello()方法，在方法接受者已经确定是对象“sp”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。编译器在重载时通过参数的静态类型而不是实际类型作为判断依据的，因此在编译阶段Java编译器根据参数的静态类型决定使用哪个重载版本。 静态分派优先级 public class Overload { private static void sayHello(char arg){ System.out.println(\"hello char\"); } private static void sayHello(Object arg){ System.out.println(\"hello Object\"); } private static void sayHello(int arg){ System.out.println(\"hello int\"); } private static void sayHello(char... arg){ System.out.println(\"hello cHAR...\"); } // 测试代码 public static void main(String[] args) { sayHello('a'); } } // 运行结果 hello char 优先级顺序为：char>int>long>float>double>Character>Serializable>Object>... 其中...为变长参数，将其视为一个数组元素。变长参数的重载优先级最低。 因为 char 转型到 byte 或 short 的过程是不安全的，所以不会选择参数类型为byte 或 short的方法进行重载，故优先级列表里也没有。 上面讲解的主要是 基本数据类型的优先级匹配问题 若是引用类型，则根据 继承关系 进行优先级匹配 动态分派 // 定义类 class Human { public void sayHello(){ System.out.println(\"Human say hello\"); } } // 继承自 抽象类Human 并 重写sayHello() class Man extends Human { @Override protected void sayHello() { System.out.println(\"man say hello\"); } } class Woman extends Human { @Override protected void sayHello() { System.out.println(\"woman say hello\"); } } // 测试代码 public static void main(String[] args) { // 情况1 Human man = new man(); man.sayHello(); // 情况2 man = new Woman(); man.sayHello(); } } // 运行结果 man say hello woman say hello invokevirtual指令多态查找执行的第一步就是在运行期确定接收者（执行sayhello方法的对象）的实际类型，第二步将常量池中类方法符号引用解析到不同的直接引用上。这个过程就是Java语言中方法重写的本质。 两者的区别 类型 分派原理 发生阶段 应用场景 静态分派 根据变量的静态类型 编译器（不由虚拟机执行） 方法重载 动态分派 根据变量的动态类型 运行期（由虚拟机执行） 方法重写 "},"content/JavaBasic/泛型.html":{"url":"content/JavaBasic/泛型.html","title":"泛型","keywords":"","body":"泛型的定义 泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。其存在的意义在于： 强制的类型检查：Java 编译器会对泛型代码进行强制类型检查，如果违反类型安全则会抛出错误。在编译阶段解决类型错误，能更有效的减少 Bug 消除类型强制转换：如果不使用泛型，则在进行代码编写是需要手动进行类型转换 实现通用算法：通过泛型，程序员能在不同类型的集合上实现通用算法 泛型类、方法、接口 /** * Description: 泛型方法 */ public class GenericMethod3 { static class Animal { @Override public String toString() { return \"Animal\"; } } static class Dog extends Animal { @Override public String toString() { return \"Dog\"; } } static class Fruit { @Override public String toString() { return \"Fruit\"; } } //泛型类 static class GenericClass { public void show01(T t) { System.out.println(t.toString()); } //泛型方法 public void show02(T t) { System.out.println(t.toString()); } public void show03(K k) { System.out.println(k.toString()); } } public static void main(String[] args) { Animal animal = new Animal(); Dog dog = new Dog(); Fruit fruit = new Fruit(); GenericClass genericClass = new GenericClass<>(); //泛型类在初始化时限制了参数类型 genericClass.show01(dog); // genericClass.show01(fruit); //泛型方法的参数类型在使用时指定 genericClass.show02(dog); genericClass.show02(fruit); genericClass.show03(animal); genericClass.show03(dog); genericClass.show03(fruit); // genericClass.show03(animal); } } 通配符 指定了泛型类型的上界 指定了泛型类型的下界 指定了没有限制的泛型类型 类型擦除（泛型的实现） Java 语言引入了泛型，以在编译时提供更严格的类型检查并支持泛型编程。为实现泛型 Java 编译器会进行类型擦除： 替换所有类型参数为他们的上界或者 Object，因此，字节码仅包含普通的类，接口和方法。 必要时插入类型转换，以保持类型安全。 生成桥接方法以在扩展的泛型类型中保留多态。 类型擦除可确保不会为参数化类型创建新的类；因此，泛型不会产生运行时开销。 泛型类型的擦除 在类型擦除过程中，Java 编译器将擦除所有类型参数，如果类型参数是有界的，则将每个参数替换为其第一个边界；如果类型参数是无界的，则将其替换为 Object。 public class Node { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } 由于 T 是无界的，所以其类型擦除后的代码为： public class Node { private Object data; private Node next; public Node(Object data, Node next) { this.data = data; this.next = next; } public Object getData() { return data; } // ... } 而对于以下代码的擦除又不一样： public class Node> { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } //擦除后 public class Node { private Comparable data; private Node next; public Node(Comparable data, Node next) { this.data = data; this.next = next; } public Comparable getData() { return data; } // ... } 泛型方法擦除 泛型方法的擦除规则和泛型类型的擦除规则类似： // Counts the number of occurrences of elem in anArray. public static int count(T[] anArray, T elem) { int cnt = 0; for (T e : anArray) if (e.equals(elem)) ++cnt; return cnt; } public static void draw(T shape) { /* ... */ } //擦除后 public static int count(Object[] anArray, Object elem) { int cnt = 0; for (Object e : anArray) if (e.equals(elem)) ++cnt; return cnt; } public static void draw(Shape shape) { /* ... */ } 桥接方法 对于以下两个类： public class Node { public T data; public Node(T data) { this.data = data; } public void setData(T data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } 类型擦除： public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } 在类型擦除后，方法的签名不匹配，导致重写的方法不生效，Node.setData(T) 变成了 Node.setData(Object)。为解决这个问题，Java 编译器在子类型中生成桥接方法，对于 MyNode 其生成的方法如下： class MyNode extends Node { // Bridge method generated by the compiler // public void setData(Object data) { setData((Integer) data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } // ... } 这样，在类型擦除之后，MyNode 具有与 Node 的 setData(Object) 方法相同的方法签名的桥接方法，并将其委托给的 setData(Integer) 方法。 "},"content/JavaConcurrency/JMM.html":{"url":"content/JavaConcurrency/JMM.html","title":"内存模型JMM","keywords":"","body":"JMM的定义 Java内存模型(Java Memory Model简称JMM)是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。 JMM 抽象模型分为主内存、工作内存。主内存是共享内存区域，所有变量都存储在主内存。工作内存是每个线程独占的，线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存。线程间的通信(传值)必须通过主内存来完成。 此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的。主内存从某个程度上讲应该包括了堆和方法区，而工作内存从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。 JMM内存交互操作 lock(锁定)作用于主内存的变量，把一个变量标记为一条线程独占状态 unlock(解锁):作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read(读取):作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load(载入):作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use(使用):作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎。 assign(赋值):作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量。 store(存储):作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中， 以便随后的write的操作。 write(写入):作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中。 JMM内存同步规则 如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作， 如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。 不允许一个线程无原因地(没有发生过任何assign操作)把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load 或者assign)的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load 操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复 执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和 unlock必须成对出现。 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变 量之前需要重新执行load或assign操作初始化变量的值。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中(执行store和write操 作) "},"content/MiddleWare/redis.html":{"url":"content/MiddleWare/redis.html","title":"test3","keywords":"","body":"test markdown 级六级考六级了剋 i 还不是个看不见各地广泛的高大上 Nkjhk weee jkhb kkk "}}